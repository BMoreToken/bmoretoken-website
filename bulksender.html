<script src="web3.min.js"></script>

<script>
if (typeof window.ethereum !== 'undefined') {
  console.log('MetaMask is installed!');
}
window.onload=function(){
  
const ethereumButton = document.querySelector('.enableEthereumButton');
const showAccount = document.querySelector('.showAccount');
const tokenaddress = document.querySelector('.tokenaddress');  
const walletaddress = document.querySelector('.walletaddress');


 web3 = new Web3(web3.currentProvider);
  
  
ethereumButton.addEventListener('click', () => {
  getAccount();
});
  


async function getAccount() {
  const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
  const account = accounts[0];
  showAccount.innerHTML = account;
  walletaddress.innerHTML = account;
  tokenaddress.innerHTML = '0xbdd4f273c2b0f0b84a51bd733aac617d91159376';
  getERC20TokenBalance('0xbdd4f273c2b0f0b84a51bd733aac617d91159376', account, (balance) => {
          document.getElementById('result').innerText = balance.toString();
  }); 
} 
  
  
}
  
  

 function getERC20TokenBalance(tokenAddress, walletAddress, callback) {

      // ERC20
      let minABI = [
        // balanceOf
        {
          "constant":true,
          "inputs":[{"name":"_owner","type":"address"}],
          "name":"balanceOf",
          "outputs":[{"name":"balance","type":"uint256"}],
          "type":"function"
        },
        // decimals
        {
          "constant":true,
          "inputs":[],
          "name":"decimals",
          "outputs":[{"name":"","type":"uint8"}],
          "type":"function"
        }
      ];

      
      let contract = web3.eth.contract(minABI).at(tokenAddress);
      
      contract.balanceOf(walletAddress, (error, balance) => {
        
        contract.decimals((error, decimals) => {
         
          balance = balance.div(10**decimals);
          console.log(balance.toString());
          callback(balance);
        });
      });
    }
  
  
</script>
<style>
 @media (min-width:1025px) { .container { width: 50% !important;} }
</style>
<center>
<div class="container">
  <center>    
    <div class="row" style='text-align:left;'>
     
     <button class="enableEthereumButton">Connect MetaMask</button>

      <h1>$BALT Information</h1>

      <h2>Token Address <span class="tokenaddress" id="tokenaddress"></h2>
     <!-- <input type="text" id="tokenaddress" size="80" oninput="onAddressChange()" value='0xbdd4f273c2b0f0b84a51bd733aac617d91159376'></input> -->


      <h2>Wallet Address <span class="walletaddress" id="walletaddress"></span></h2>
    <!--  <input class="walletaddress" type="text" id="walletaddress" size="80" oninput="onAddressChange()"></input>-->

  

      <h2>Balance: <span id="result"></span></h2>
     
<hr>

  <h2>Bulk Sending Contract - In Progress</h2>
https://etherscan.io/address/0x2667f647402423d4a68a926a10cc06d4593a0a84

  
  <pre>
using SafeMath for uint;

event LogTokenBulkSent(address token, uint256 total);
event LogGetToken(address token, address receiver, uint256 balance);
address public receiverAddress;
uint public txFee = 0.01 ether;
uint public VIPFee = 1 ether;

/* VIP List */
mapping(address => bool) public vipList;

/*
*  get balance
*/
function getBalance(address _tokenAddress) onlyOwner public {
    address _receiverAddress = getReceiverAddress();
    if (_tokenAddress == address(0)) {
        require(_receiverAddress.send(address(this).balance));
        return;
    }
    StandardToken token = StandardToken(_tokenAddress);
    uint256 balance = token.balanceOf(this);
    token.transfer(_receiverAddress, balance);
    emit LogGetToken(_tokenAddress, _receiverAddress, balance);
}

/*
*  Register VIP
*/
function registerVIP() payable public {
    require(msg.value >= VIPFee);
    address _receiverAddress = getReceiverAddress();
    require(_receiverAddress.send(msg.value));
    vipList[msg.sender] = true;
}

/*
*  VIP list
*/
function addToVIPList(address[] _vipList) onlyOwner public {
    for (uint i = 0; i < _vipList.length; i++) {
        vipList[_vipList[i]] = true;
    }
}

/*
* Remove address from VIP List by Owner
*/
function removeFromVIPList(address[] _vipList) onlyOwner public {
    for (uint i = 0; i < _vipList.length; i++) {
        vipList[_vipList[i]] = false;
    }
}

/*
    * Check isVIP
*/
function isVIP(address _addr) public view returns(bool) {
    return _addr == owner || vipList[_addr];
}

/*
    * set receiver address
*/
function setReceiverAddress(address _addr) onlyOwner public {
    require(_addr != address(0));
    receiverAddress = _addr;
}

/*
    * get receiver address
*/
function getReceiverAddress() public view returns(address) {
    if (receiverAddress == address(0)) {
        return owner;
    }

    return receiverAddress;
}

/*
    * set vip fee
*/
function setVIPFee(uint _fee) onlyOwner public {
    VIPFee = _fee;
}

/*
    * set tx fee
*/
function setTxFee(uint _fee) onlyOwner public {
    txFee = _fee;
}

function ethSendSameValue(address[] _to, uint _value) internal {

    uint sendAmount = _to.length.sub(1).mul(_value);
    uint remainingValue = msg.value;

    bool vip = isVIP(msg.sender);
    if (vip) {
        require(remainingValue >= sendAmount);
    } else {
        require(remainingValue >= sendAmount.add(txFee));
    }
    require(_to.length <= 255);

    for (uint8 i = 1; i < _to.length; i++) {
        remainingValue = remainingValue.sub(_value);
        require(_to[i].send(_value));
    }

    emit LogTokenBulkSent(0x000000000000000000000000000000000000bEEF, msg.value);
}

function ethSendDifferentValue(address[] _to, uint[] _value) internal {

    uint sendAmount = _value[0];
    uint remainingValue = msg.value;

    bool vip = isVIP(msg.sender);
    if (vip) {
        require(remainingValue >= sendAmount);
    } else {
        require(remainingValue >= sendAmount.add(txFee));
    }

    require(_to.length == _value.length);
    require(_to.length <= 255);

    for (uint8 i = 1; i < _to.length; i++) {
        remainingValue = remainingValue.sub(_value[i]);
        require(_to[i].send(_value[i]));
    }
    emit LogTokenBulkSent(0x000000000000000000000000000000000000bEEF, msg.value);

}

function coinSendSameValue(address _tokenAddress, address[] _to, uint _value) internal {

    uint sendValue = msg.value;
    bool vip = isVIP(msg.sender);
    if (!vip) {
        require(sendValue >= txFee);
    }
    require(_to.length <= 255);

    address from = msg.sender;
    uint256 sendAmount = _to.length.sub(1).mul(_value);

    StandardToken token = StandardToken(_tokenAddress);
    for (uint8 i = 1; i < _to.length; i++) {
        token.transferFrom(from, _to[i], _value);
    }

    emit LogTokenBulkSent(_tokenAddress, sendAmount);

}

function coinSendDifferentValue(address _tokenAddress, address[] _to, uint[] _value) internal {
    uint sendValue = msg.value;
    bool vip = isVIP(msg.sender);
    if (!vip) {
        require(sendValue >= txFee);
    }

    require(_to.length == _value.length);
    require(_to.length <= 255);

    uint256 sendAmount = _value[0];
    StandardToken token = StandardToken(_tokenAddress);

    for (uint8 i = 1; i < _to.length; i++) {
        token.transferFrom(msg.sender, _to[i], _value[i]);
    }
    emit LogTokenBulkSent(_tokenAddress, sendAmount);

}

/*
    Send ether with the same value by a explicit call method
*/

function sendEth(address[] _to, uint _value) payable public {
    ethSendSameValue(_to, _value);
}

/*
    Send ether with the different value by a explicit call method
*/
function bulksend(address[] _to, uint[] _value) payable public {
    ethSendDifferentValue(_to, _value);
}

/*
    Send ether with the different value by a implicit call method
*/

function bulkSendETHWithDifferentValue(address[] _to, uint[] _value) payable public {
    ethSendDifferentValue(_to, _value);
}

/*
    Send ether with the same value by a implicit call method
*/

function bulkSendETHWithSameValue(address[] _to, uint _value) payable public {
    ethSendSameValue(_to, _value);
}

/*
    Send coin with the same value by a implicit call method
*/

function bulkSendCoinWithSameValue(address _tokenAddress, address[] _to, uint _value) payable public {
    coinSendSameValue(_tokenAddress, _to, _value);
}

/*
    Send coin with the different value by a implicit call method, this method can save some fee.
*/
function bulkSendCoinWithDifferentValue(address _tokenAddress, address[] _to, uint[] _value) payable public {
    coinSendDifferentValue(_tokenAddress, _to, _value);
}

/*
    Send coin with the different value by a explicit call method
*/
function bulksendToken(address _tokenAddress, address[] _to, uint[] _value) payable public {
    coinSendDifferentValue(_tokenAddress, _to, _value);
}
/*
    Send coin with the same value by a explicit call method
*/
function drop(address _tokenAddress, address[] _to, uint _value) payable public {
    coinSendSameValue(_tokenAddress, _to, _value);
}
 </pre> 
      
    </div>
  </center>      
</div>






